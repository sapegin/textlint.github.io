// LICENSE : MIT
"use strict";
/*
    textlint-core.js is a class
    textlint.js is a singleton object that is instance of textlint-core.js.
 */
Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _taskTextlintCoreTask = require("./task/textlint-core-task");

var _taskTextlintCoreTask2 = _interopRequireDefault(_taskTextlintCoreTask);

var _ruleRuleCreatorHelper = require("./rule/rule-creator-helper");

var _taskFixerTask = require("./task/fixer-task");

var _taskFixerTask2 = _interopRequireDefault(_taskFixerTask);

var _taskLinterTask = require("./task/linter-task");

var _taskLinterTask2 = _interopRequireDefault(_taskLinterTask);

var _utilProccesorHelper = require("./util/proccesor-helper");

var _textlintPluginMarkdown = require("textlint-plugin-markdown");

var _textlintPluginText = require("textlint-plugin-text");

var Promise = require("bluebird");
var path = require("path");
var fs = require("fs");
var assert = require("assert");
var SourceCode = require("./rule/source-code");
var SourceCodeFixer = require("./fixer/source-code-fixer");
var debug = require("debug")("textlint:core");

var TextlintCore = (function () {
    function TextlintCore() {
        var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, TextlintCore);

        // this.config often is undefined.
        this.config = config;
        this.rules = {};
        this.rulesConfig = {};
        // FIXME: in the future, this.processors is empty by default.
        // Markdown and Text are for backward compatibility.
        this.processors = [new _textlintPluginMarkdown.Processor(config), new _textlintPluginText.Processor(config)];
    }

    // unstable API

    _createClass(TextlintCore, [{
        key: "addProcessor",
        value: function addProcessor(Processor) {
            // add first
            this.processors.unshift(new Processor(this.config));
        }

        /**
         * Register rules to EventEmitter.
         * if want to release rules, please call {@link this.resetRules}.
         * @param {object} rules rule objects array
         * @param {object} [rulesConfig] ruleConfig is object
         */
    }, {
        key: "setupRules",
        value: function setupRules() {
            var rules = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            var rulesConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var ignoreDisableRules = function ignoreDisableRules(rules) {
                var resultRules = Object.create(null);
                Object.keys(rules).forEach(function (key) {
                    var ruleCreator = rules[key];
                    (0, _ruleRuleCreatorHelper.assertRuleShape)(ruleCreator, key);
                    // "rule-name" : false => disable
                    var ruleConfig = rulesConfig && rulesConfig[key];
                    if (ruleConfig !== false) {
                        debug("use \"%s\" rule", key);
                        resultRules[key] = rules[key];
                    }
                });
                return resultRules;
            };
            this.rules = ignoreDisableRules(rules);
            this.rulesConfig = rulesConfig;
        }

        /**
         * Remove all registered rule and clear messages.
         */
    }, {
        key: "resetRules",
        value: function resetRules() {
            // noop
        }
    }, {
        key: "_lintByProcessor",
        value: function _lintByProcessor(processor, text, ext, filePath) {
            assert(processor, "processor is not found for " + ext);

            var _processor$processor = processor.processor(ext);

            var preProcess = _processor$processor.preProcess;
            var postProcess = _processor$processor.postProcess;

            assert(typeof preProcess === "function" && typeof postProcess === "function", "processor should implement {preProcess, postProcess}");
            var ast = preProcess(text, filePath);
            var sourceCode = new SourceCode({
                text: text,
                ast: ast,
                ext: ext,
                filePath: filePath
            });
            var task = new _taskLinterTask2["default"]({
                config: this.config,
                rules: this.rules,
                rulesConfig: this.rulesConfig,
                sourceCode: sourceCode
            });
            return new Promise(function (resolve, reject) {
                var messages = [];
                task.on(_taskTextlintCoreTask2["default"].events.message, function (message) {
                    messages.push(message);
                });
                task.on(_taskTextlintCoreTask2["default"].events.error, function (error) {
                    reject(error);
                });
                task.on(_taskTextlintCoreTask2["default"].events.complete, function () {
                    var result = postProcess(messages, filePath);
                    if (result.filePath == null) {
                        result.filePath = "<Unkown" + ext + ">";
                    }
                    assert(result.filePath && result.messages.length >= 0, "postProcess should return { messages, filePath } ");
                    resolve(result);
                });
                task.process(ast);
            });
        }

        /**
         * lint text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text
         * @param {string} ext ext is extension. default: .txt
         * @returns {TextLintResult}
         */
    }, {
        key: "lintText",
        value: function lintText(text) {
            var ext = arguments.length <= 1 || arguments[1] === undefined ? ".txt" : arguments[1];

            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext);
        }

        /**
         * lint markdown text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text markdown format text
         * @returns {TextLintResult}
         */
    }, {
        key: "lintMarkdown",
        value: function lintMarkdown(text) {
            var ext = ".md";
            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext);
        }

        /**
         * lint file and return result object
         * @param {string} filePath
         * @returns {TextLintResult} result
         */
    }, {
        key: "lintFile",
        value: function lintFile(filePath) {
            var absoluteFilePath = path.resolve(process.cwd(), filePath);
            var ext = path.extname(absoluteFilePath);
            var text = fs.readFileSync(absoluteFilePath, "utf-8");
            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._lintByProcessor(processor, text, ext, absoluteFilePath);
        }

        /**
         * fix file and return fix result object
         * @param {string} filePath
         * @returns {TextLintFixResult}
         */
    }, {
        key: "fixFile",
        value: function fixFile(filePath) {
            var absoluteFilePath = path.resolve(process.cwd(), filePath);
            var ext = path.extname(absoluteFilePath);
            var text = fs.readFileSync(absoluteFilePath, "utf-8");
            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._fixProcess(processor, text, ext, filePath);
        }

        /**
         * fix texts and return fix result object
         * @param {string} text
         * @param {string} ext
         * @returns {TextLintFixResult}
         */
    }, {
        key: "fixText",
        value: function fixText(text) {
            var ext = arguments.length <= 1 || arguments[1] === undefined ? ".txt" : arguments[1];

            var processor = (0, _utilProccesorHelper.getProcessorMatchExtension)(this.processors, ext);
            return this._fixProcess(processor, text, ext);
        }
    }, {
        key: "_fixProcess",
        value: function _fixProcess(processor, text, ext, filePath) {
            var _this = this;

            var fixerRules = Object.keys(this.rules).map(function (ruleName) {
                return {
                    ruleName: ruleName,
                    rule: _this.rules[ruleName]
                };
            }).filter(function (_ref) {
                var rule = _ref.rule;

                return typeof rule.fixer !== "undefined";
            });

            var _processor$processor2 = processor.processor(ext);

            var preProcess = _processor$processor2.preProcess;
            var postProcess = _processor$processor2.postProcess;

            // messages
            var resultFilePath = filePath;
            var applyingMessages = [];
            var remainingMessages = [];
            var originalMessages = [];
            var fixerProcessList = fixerRules.map(function (_ref2) {
                var ruleName = _ref2.ruleName;
                var rule = _ref2.rule;

                return function (sourceText) {
                    // create new SourceCode object
                    var newSourceCode = new SourceCode({
                        text: sourceText,
                        ast: preProcess(sourceText),
                        filePath: filePath,
                        ext: ext
                    });
                    // create new Task
                    var task = new _taskFixerTask2["default"]({
                        config: _this.config,
                        // { ruleName : rule }
                        rules: _defineProperty({}, ruleName, rule),
                        rulesConfig: _this.rulesConfig,
                        sourceCode: newSourceCode
                    });
                    return new Promise(function (resolve, reject) {
                        var messages = [];
                        task.on(_taskTextlintCoreTask2["default"].events.message, function (message) {
                            messages.push(message);
                        });
                        task.on(_taskTextlintCoreTask2["default"].events.error, function (error) {
                            reject(error);
                        });
                        task.on(_taskTextlintCoreTask2["default"].events.complete, function () {
                            var result = postProcess(messages, filePath);
                            resultFilePath = result.filePath;
                            var applied = SourceCodeFixer.applyFixes(newSourceCode, result.messages);
                            // add messages
                            Array.prototype.push.apply(applyingMessages, applied.applyingMessages);
                            Array.prototype.push.apply(remainingMessages, applied.remainingMessages);
                            Array.prototype.push.apply(originalMessages, applied.messages);
                            // if not fixed, still use current sourceText
                            if (!applied.fixed) {
                                return resolve(sourceText);
                            }
                            // if fixed, use fixed text at next
                            resolve(applied.output);
                        });
                        task.process(newSourceCode.ast);
                    });
                };
            });

            var promiseTask = fixerProcessList.reduce(function (promise, fixerProcess) {
                return promise.then(function (sourceText) {
                    return fixerProcess(sourceText);
                });
            }, Promise.resolve(text));

            return promiseTask.then(function (output) {
                debug("Finish Processing: " + resultFilePath);
                debug("applyingMessages: " + applyingMessages.length);
                debug("remainingMessages: " + remainingMessages.length);
                return {
                    filePath: resultFilePath,
                    output: output,
                    originalMessages: originalMessages,
                    applyingMessages: applyingMessages,
                    remainingMessages: remainingMessages
                };
            });
        }
    }]);

    return TextlintCore;
})();

exports["default"] = TextlintCore;
module.exports = exports["default"];
//# sourceMappingURL=textlint-core.js.map
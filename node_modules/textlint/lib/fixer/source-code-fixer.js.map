{"version":3,"sources":["../../src/fixer/source-code-fixer.js"],"names":[],"mappings":"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","file":"source-code-fixer.js","sourcesContent":["const debug = require(\"debug\")(\"textlint:source-code-fixer\");\nimport SourceCode from \"../rule/source-code\";\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by line and column.\n * @param {TextLintMessage} a The first message.\n * @param {TextLintMessage} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    const lineDiff = a.line - b.line;\n\n    if (lineDiff === 0) {\n        return a.column - b.column;\n    } else {\n        return lineDiff;\n    }\n}\n\nfunction clone(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\n\nexport default class SourceCodeFixer {\n    /**\n     * Applies the fixes specified by the messages to the given text. Tries to be\n     * smart about the fixes and won't apply fixes over the same area in the text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} messages The array of messages reported by ESLint.\n     * @returns {Object} An object containing the fixed text and any unfixed messages.\n     */\n    static applyFixes(sourceCode, messages) {\n        debug(\"Applying fixes\");\n        const text = sourceCode.text;\n        // As as result, show diff\n        const remainingMessages = [];\n        const applyingMessages = [];\n        const cloneMessages = messages.slice();\n        const fixes = [];\n        let lastFixPos = text.length + 1;\n        let prefix = (sourceCode.hasBOM ? BOM : \"\");\n        cloneMessages.forEach(problem => {\n            if (problem && problem.hasOwnProperty(\"fix\")) {\n                fixes.push(problem);\n            } else {\n                remainingMessages.push(problem);\n            }\n        });\n\n        if (fixes.length) {\n            debug(\"Found fixes to apply\");\n\n            // sort in reverse order of occurrence\n            fixes.sort((a, b) => {\n                if (a.fix.range[1] <= b.fix.range[0]) {\n                    return 1;\n                } else {\n                    return -1;\n                }\n            });\n\n            // split into array of characters for easier manipulation\n            const chars = text.split(\"\");\n\n            fixes.forEach(problem => {\n                // pickup fix range\n                const fix = problem.fix;\n                let start = fix.range[0];\n                const end = fix.range[1];\n                let insertionText = fix.text;\n\n                if (end < lastFixPos) {\n                    if (start < 0) {\n                        // Remove BOM.\n                        prefix = \"\";\n                        start = 0;\n                    }\n                    if (start === 0 && insertionText[0] === BOM) {\n                        // Set BOM.\n                        prefix = BOM;\n                        insertionText = insertionText.slice(1);\n                    }\n\n                    const replacedChars = chars.splice(start, end - start, insertionText);\n                    lastFixPos = start;\n                    const copyOfMessage = clone(problem);\n                    copyOfMessage.fix = {\n                        range: [start, start + insertionText.length],\n                        text: replacedChars.join(\"\")\n                    };\n                    applyingMessages.push(copyOfMessage);\n                } else {\n                    remainingMessages.push(problem);\n                }\n            });\n\n            return {\n                fixed: true,\n                messages: cloneMessages,// have order\n                applyingMessages: applyingMessages.reverse(),// have order\n                remainingMessages: remainingMessages.sort(compareMessagesByLocation),// have not order\n                output: prefix + chars.join(\"\")\n            };\n        } else {\n            debug(\"No fixes to apply\");\n            return {\n                fixed: false,\n                messages: cloneMessages,\n                applyingMessages,\n                remainingMessages,\n                output: prefix + text\n            };\n        }\n    }\n\n    /**\n     * Sequentially Applies the fixes specified by the messages to the given text.\n     * @param {SourceCode} sourceCode The source code to apply the changes to.\n     * @param {TextLintMessage[]} applyingMessages The array of TextLintMessage reported by SourceCodeFixer#applyFixes\n     * @returns {string} An object containing the fixed text and any unfixed messages.\n     */\n    static sequentiallyApplyFixes(sourceCode, applyingMessages) {\n        debug(\"Restore applied fixes\");\n        let text = sourceCode.text;\n        applyingMessages.forEach(message => {\n            const newSource = new SourceCode({\n                text,\n                ast: sourceCode.ast, // it's dummy\n                ext: sourceCode.ext,\n                filePath: sourceCode.filePath\n            });\n            const result = SourceCodeFixer.applyFixes(newSource, [message]);\n            text = result.output;\n        });\n        return text;\n    }\n}"]}
// LICENSE : MIT
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _textlintCore = require("./textlint-core");

var _textlintCore2 = _interopRequireDefault(_textlintCore);

var _utilConfigUtil = require("./util/config-util");

var _utilFindUtil = require("./util/find-util");

var _utilLogger = require("./util/logger");

var _utilLogger2 = _interopRequireDefault(_utilLogger);

var Promise = require("bluebird");
var interopRequire = require("interop-require");

var RuleManager = require("./rule/rule-manager");
var Config = require("./config/config");
var createFormatter = require("textlint-formatter");
var tryResolve = require("try-resolve");
var path = require("path");

var debug = require("debug")("textlint:cli-engine");

var TextLintEngine = (function () {
    /**
     * Process files are wanted to lint.
     * TextLintEngine is a wrapper of textlint.js.
     * Aim to be called from cli with cli options.
     * @param {TextLintConfig} options the options is command line options or Config object.
     * @constructor
     */

    function TextLintEngine(options) {
        _classCallCheck(this, TextLintEngine);

        /**
         * @type {Config}
         */
        this.config = null;
        if (options instanceof Config) {
            // Almost internal use-case
            this.config = options;
        } else {
            this.config = Config.initWithAutoLoading(options);
        }

        /**
         * @type {TextLintCore}
         */
        this.textLint = new _textlintCore2["default"](this.config);

        this.ruleManager = new RuleManager();
        // load rule/plugin/processor
        this._setupRules(this.config);
        // execute files that are filtered by availableExtensions.
        this.availableExtensions = this.textLint.processors.reduce(function (availableExtensions, processor) {
            var Processor = processor.constructor;
            return availableExtensions.concat(Processor.availableExtensions());
        }, this.config.extensions);
    }

    /**
     * set up lint rules using {@lint Config} object.
     * The {@lint Config} object was created with initialized {@link TextLintEngine} (as-known Constructor).
     * @param {Config} config the config is parsed object
     * @private
     */

    _createClass(TextLintEngine, [{
        key: "_setupRules",
        value: function _setupRules(config) {
            var _this = this;

            debug("config %O", config);
            // --ruledir
            if (config.rulePaths) {
                // load in additional rules
                config.rulePaths.forEach(function (rulesdir) {
                    debug("Loading rules from %o", rulesdir);
                    _this.ruleManager.loadRules(rulesdir);
                });
            }
            // --rule
            if (config.rules) {
                // load in additional rules
                config.rules.forEach(function (ruleName) {
                    _this.loadRule(ruleName);
                });
            }
            // --preset
            if (config.presets) {
                config.presets.forEach(function (presetName) {
                    _this.loadPreset(presetName);
                });
            }
            // --plugin
            if (config.plugins) {
                // load in additional rules from plugin
                config.plugins.forEach(function (pluginName) {
                    var plugin = _this.loadPlugin(pluginName);
                    // register plugin.Processor
                    if (plugin.hasOwnProperty("Processor")) {
                        _this.textLint.addProcessor(plugin.Processor);
                    }
                });
            }
            var textlintConfig = config ? config.toJSON() : {};
            this.textLint.setupRules(this.ruleManager.getAllRules(), textlintConfig.rulesConfig);
        }

        /**
         * add rule to config.rules
         * if rule already exists, then not added
         * @param {string} ruleName
         */
    }, {
        key: "addRule",
        value: function addRule(ruleName) {
            if (Array.isArray(this.config.rules) && this.config.rules.indexOf(ruleName) === -1) {
                this.config.rules.push(ruleName);
                this._setupRules(this.config);
            }
        }

        /**
         * set directory to use as root directory to load rule.
         * @param {string} directory as root directory to load rule
         * @deprecated please use
         *
         * ```
         * new TextLintEngine({
         *  rulesBaseDirectory: directory
         * })
         * ```
         */
    }, {
        key: "setRulesBaseDirectory",
        value: function setRulesBaseDirectory(directory) {
            this.config.rulesBaseDirectory = directory;
            this._setupRules(this.config);
        }

        /**
         * load rule from plugin name.
         * plugin module has `rules` object and define rule with plugin prefix.
         * @param {string} pluginName
         */
    }, {
        key: "loadPlugin",
        value: function loadPlugin(pluginName) {
            // TODO: ignore already loaded plugin
            var PLUGIN_NAME_PREFIX = this.config.constructor.PLUGIN_NAME_PREFIX;
            var prefixMatch = new RegExp("^" + PLUGIN_NAME_PREFIX);
            var pluginNameWithoutPrefix = pluginName.replace(prefixMatch, "");
            var baseDir = this.config.rulesBaseDirectory || "";
            var textlintRuleName = "" + PLUGIN_NAME_PREFIX + pluginName;
            var pkgPath = tryResolve(path.join(baseDir, textlintRuleName)) || tryResolve(path.join(baseDir, pluginName));
            if (!pkgPath) {
                throw new ReferenceError("plugin: " + pluginName + " is not found");
            }
            debug("Loading rules from plugin: %s", pkgPath);
            var plugin = interopRequire(pkgPath);
            // Processor plugin doesn't define rules
            if (plugin.hasOwnProperty("rules")) {
                this.ruleManager.importPlugin(plugin.rules, pluginNameWithoutPrefix);
            }
            return plugin;
        }
    }, {
        key: "loadPreset",
        value: function loadPreset(presetName) {
            // ignore already defined rule
            // ignore rules from rulePaths because avoid ReferenceError is that try to require.
            var RULE_NAME_PREFIX = this.config.constructor.RULE_NAME_PREFIX;
            var prefixMatch = new RegExp("^" + RULE_NAME_PREFIX);
            var presetRuleNameWithoutPrefix = presetName.replace(prefixMatch, "");
            // ignore plugin's rule
            if ((0, _utilConfigUtil.isPluginRuleKey)(presetRuleNameWithoutPrefix)) {
                _utilLogger2["default"].warn(presetRuleNameWithoutPrefix + " is Plugin's rule. This is unknown case, please report issue.");
                return;
            }
            var baseDir = this.config.rulesBaseDirectory || "";
            var textlintRuleName = "" + RULE_NAME_PREFIX + presetRuleNameWithoutPrefix;
            var pkgPath = tryResolve(path.join(baseDir, textlintRuleName)) || tryResolve(path.join(baseDir, presetName));
            if (!pkgPath) {
                throw new ReferenceError("preset: " + presetRuleNameWithoutPrefix + " is not found");
            }
            debug("Loading rules from preset: %s", pkgPath);
            var preset = interopRequire(pkgPath);
            // Processor plugin doesn't define rules
            this.ruleManager.importPlugin(preset.rules, presetRuleNameWithoutPrefix);
            return preset;
        }

        /**
         * load rule file with `ruleName` and define rule.
         * if rule is not found, then throw ReferenceError.
         * if already rule is loaded, do not anything.
         * @param {string} ruleName
         */
    }, {
        key: "loadRule",
        value: function loadRule(ruleName) {
            // ignore already defined rule
            // ignore rules from rulePaths because avoid ReferenceError is that try to require.
            var RULE_NAME_PREFIX = this.config.constructor.RULE_NAME_PREFIX;
            var prefixMatch = new RegExp("^" + RULE_NAME_PREFIX);
            var definedRuleName = ruleName.replace(prefixMatch, "");
            // ignore plugin's rule
            if ((0, _utilConfigUtil.isPluginRuleKey)(definedRuleName)) {
                _utilLogger2["default"].warn(definedRuleName + " is Plugin's rule. This is unknown case, please report issue.");
                return;
            }
            if (this.ruleManager.isDefinedRule(definedRuleName)) {
                return;
            }
            var baseDir = this.config.rulesBaseDirectory || "";
            var textlintRuleName = "" + RULE_NAME_PREFIX + ruleName;
            var pkgPath = tryResolve(path.join(baseDir, textlintRuleName)) || tryResolve(path.join(baseDir, ruleName));
            if (!pkgPath) {
                throw new ReferenceError("rule: " + ruleName + " is not found");
            }
            debug("Loading rules from %s", pkgPath);
            var ruleCreator = interopRequire(pkgPath);
            this.ruleManager.defineRule(definedRuleName, ruleCreator);
        }

        /**
         * Remove all registered rule and clear messages.
         */
    }, {
        key: "resetRules",
        value: function resetRules() {
            this.textLint.resetRules();
            this.ruleManager.resetRules();
        }

        /**
         * Executes the current configuration on an array of file and directory names.
         * @param {String[]}  files An array of file and directory names.
         * @returns {TextLintResult[]} The results for all files that were linted.
         */
    }, {
        key: "executeOnFiles",
        value: function executeOnFiles(files) {
            var _this2 = this;

            var targetFiles = (0, _utilFindUtil.findFiles)(files, this.availableExtensions);
            var results = targetFiles.map(function (file) {
                return _this2.textLint.lintFile(file);
            });
            return Promise.all(results);
        }

        /**
         * If want to lint a text, use it.
         * But, if you have a target file, use {@link executeOnFiles} instead of it.
         * @param {string} text linting text content
         * @param {string} ext ext is a type for linting. default: ".txt"
         * @returns {TextLintResult[]}
         */
    }, {
        key: "executeOnText",
        value: function executeOnText(text) {
            var ext = arguments.length <= 1 || arguments[1] === undefined ? ".txt" : arguments[1];

            // filepath or ext
            var actualExt = ext[0] === "." ? ext : path.extname(ext);
            if (actualExt.length === 0) {
                throw new Error("should specify the extension.\nex) .md");
            }
            return this.textLint.lintText(text, actualExt).then(function (result) {
                return [result];
            });
        }

        /**
         * Fixes the current configuration on an array of file and directory names.
         * @param {String[]}  files An array of file and directory names.
         * @returns {TextLintFixResult[]} The results for all files that were linted.
         */
    }, {
        key: "fixFiles",
        value: function fixFiles(files) {
            var _this3 = this;

            var targetFiles = (0, _utilFindUtil.findFiles)(files, this.availableExtensions);
            var results = targetFiles.map(function (file) {
                return _this3.textLint.fixFile(file);
            });
            return Promise.all(results);
        }

        /**
         * Fix texts with ext option.
         *
         * @param {string} text linting text content
         * @param {string} ext ext is a type for linting. default: ".txt"
         * @returns {TextLintFixResult[]}
         */
    }, {
        key: "fixText",
        value: function fixText(text) {
            var ext = arguments.length <= 1 || arguments[1] === undefined ? ".txt" : arguments[1];

            // filepath or ext
            var actualExt = ext[0] === "." ? ext : path.extname(ext);
            if (actualExt.length === 0) {
                throw new Error("should specify the extension.\nex) .md");
            }
            return this.textLint.fixText(text, actualExt).then(function (result) {
                return [result];
            });
        }

        /**
         * format {@link results} and return output text.
         * @param {TextLintResult[]} results the collection of result
         * @returns {string} formatted output text
         * @example
         *  console.log(formatResults(results));
         */
    }, {
        key: "formatResults",
        value: function formatResults(results) {
            var formatterConfig = {
                formatterName: this.config.formatterName,
                color: this.config.color
            };
            var formatter = createFormatter(formatterConfig);
            return formatter(results);
        }

        /**
         * Checks if the given message is an error message.
         * @param {TextLintMessage} message The message to check.
         * @returns {boolean} Whether or not the message is an error message.
         */
    }, {
        key: "isErrorMessage",
        value: function isErrorMessage(message) {
            return message.severity === 2;
        }

        /**
         * Checks if the given results contain error message.
         * If there is even one error then return true.
         * @param {TextLintResult[]} results Linting result collection
         * @returns {Boolean} Whether or not the results contain error message.
         */
    }, {
        key: "isErrorResults",
        value: function isErrorResults(results) {
            var _this4 = this;

            return results.some(function (result) {
                return result.messages.some(_this4.isErrorMessage);
            });
        }
    }]);

    return TextLintEngine;
})();

module.exports = TextLintEngine;
//# sourceMappingURL=textlint-engine.js.map
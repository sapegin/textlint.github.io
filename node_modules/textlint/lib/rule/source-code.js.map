{"version":3,"sources":["../../src/rule/source-code.js"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AACjC,IAAM,gBAAgB,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AACtD,IAAM,WAAW,GAAG,OAAO,CAAC,wBAAwB,CAAC,CAAC;;;;;;;;AAQtD,SAAS,QAAQ,CAAC,GAAG,EAAE;AACnB,QAAI,CAAC,GAAG,CAAC,GAAG,EAAE;AACV,cAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KAC3D;;AAED,QAAI,CAAC,GAAG,CAAC,KAAK,EAAE;AACZ,cAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;KACvD;CACJ;;;;;;IAKoB,UAAU;AAChB,aADM,UAAU,CACf,IAA+B,EAAE;wBAAjC,IAA+B,CAA9B,IAAI;YAAJ,IAAI,6BAAG,EAAE;YAAE,GAAG,GAAf,IAA+B,CAAnB,GAAG;YAAE,GAAG,GAApB,IAA+B,CAAd,GAAG;YAAE,QAAQ,GAA9B,IAA+B,CAAT,QAAQ;;8BADzB,UAAU;;AAEvB,gBAAQ,CAAC,GAAG,CAAC,CAAC;AACd,cAAM,CAAC,GAAG,IAAI,QAAQ,EAAE,8CAA8C,CAAC,CAAC;AACxE,YAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC;AAC5C,YAAI,CAAC,IAAI,GAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,AAAC,CAAC;;;;AAIjD,YAAI,CAAC,iBAAiB,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzD,YAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACf,YAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;;AAEzB,YAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KAClB;;iBAdgB,UAAU;;eAgBlB,qBAAG;AACR,mBAAO,WAAW,CAAC;SACtB;;;eAEU,uBAAG;AACV,mBAAO,IAAI,CAAC,QAAQ,CAAC;SACxB;;;;;;;;;;;eASQ,mBAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE;AACrC,gBAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC;AAC9B,gBAAI,WAAW,IAAI,IAAI,EAAE;AACrB,uBAAO,IAAI,CAAC;aACf;AACD,gBAAI,IAAI,EAAE;AACN,oBAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,WAAW,IAAI,CAAC,CAAA,AAAC,EAAE,CAAC,CAAC,CAAC;AAC9D,oBAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,UAAU,IAAI,CAAC,CAAA,AAAC,CAAC;AAC9C,uBAAO,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;aACxC,MAAM;AACH,uBAAO,WAAW,CAAC;aACtB;SACJ;;;;;;;;;eAOc,yBAAC,GAAG,EAAE;AACjB,mBAAO,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;SACtD;;;;;;;;eAMc,yBAAC,KAAK,EAAE;AACnB,mBAAO,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;SACxD;;;;;;;;eAMc,yBAAC,GAAG,EAAE;AACjB,mBAAO,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;SACtD;;;;;;;;eAMc,yBAAC,KAAK,EAAE;AACnB,mBAAO,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;SACxD;;;WA5EgB,UAAU;;;qBAAV,UAAU","file":"source-code.js","sourcesContent":["const assert = require(\"assert\");\nconst StructuredSource = require(\"structured-source\");\nconst UnionSyntax = require(\"../parser/union-syntax\");\n/**\n * Validates that the given AST has the required information.\n * @param {TxtSyntax.TxtNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * This class represent of source code.\n */\nexport default class SourceCode {\n    constructor({text = \"\", ast, ext, filePath}) {\n        validate(ast);\n        assert(ext || filePath, \"should be set either of fileExt or filePath.\");\n        this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n        this.text = (this.hasBOM ? text.slice(1) : text);\n        /**\n         * @type StructuredSource\n         */\n        this._structuredSource = new StructuredSource(this.text);\n        this.ast = ast;\n        this.filePath = filePath;\n        // fileType .md .txt ...\n        this.ext = ext;\n    }\n\n    getSyntax() {\n        return UnionSyntax;\n    }\n\n    getFilePath() {\n        return this.filePath;\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {TxtNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string|null} The text representing the AST node.\n     */\n    getSource(node, beforeCount, afterCount) {\n        const currentText = this.text;\n        if (currentText == null) {\n            return null;\n        }\n        if (node) {\n            const start = Math.max(node.range[0] - (beforeCount || 0), 0);\n            const end = node.range[1] + (afterCount || 0);\n            return currentText.slice(start, end);\n        } else {\n            return currentText;\n        }\n    }\n\n    // StructuredSource wrapper\n    /**\n     * @param {SourceLocation} loc - location indicator.\n     * @return {[ number, number ]} range.\n     */\n    locationToRange(loc) {\n        return this._structuredSource.locationToRange(loc);\n    }\n\n    /**\n     * @param {[ number, number ]} range - pair of indice.\n     * @return {SourceLocation} location.\n     */\n    rangeToLocation(range) {\n        return this._structuredSource.rangeToLocation(range);\n    }\n\n    /**\n     * @param {Position} pos - position indicator.\n     * @return {number} index.\n     */\n    positionToIndex(pos) {\n        return this._structuredSource.positionToIndex(pos);\n    }\n\n    /**\n     * @param {number} index - index to the source code.\n     * @return {Position} position.\n     */\n    indexToPosition(index) {\n        return this._structuredSource.indexToPosition(index);\n    }\n}\n"]}
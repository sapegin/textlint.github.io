// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = textlintRousseau;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require("textlint-rule-helper");

var RuleHelper = _require.RuleHelper;

var StringSource = require("textlint-util-to-string").default;
var rousseau = require("rousseau");
var ObjectAssign = require("object-assign");
var defaultOptions = {
    // "suggestion", "warning", "error"
    showLevels: ["suggestion", "warning", "error"],
    // ignore check type of https://github.com/GitbookIO/rousseau#checks
    ignoreTypes: [],
    // ignore textlint's node type
    ignoreInlineNodeTypes: undefined
};

var mapNode = function mapNode(ast, mapFn) {
    return function preorder(node, index, parent) {
        var newNode = ObjectAssign({}, mapFn(node, index, parent));
        if (node.children) {
            newNode.children = node.children.map(function (child, index) {
                return preorder(child, index, node);
            });
        }
        return newNode;
    }(ast, null, null);
};

function textlintRousseau(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? defaultOptions : arguments[1];

    var helper = new RuleHelper(context);
    var Syntax = context.Syntax;
    var RuleError = context.RuleError;
    var report = context.report;
    var getSource = context.getSource;

    var showLevels = options.showLevels || defaultOptions.showLevels;
    var ignoreTypes = options.ignoreTypes || defaultOptions.ignoreTypes;
    var ignoreInlineNodeTypes = options.ignoreInlineNodeTypes || [Syntax.Code];
    var isShowType = function isShowType(type) {
        return ignoreTypes.indexOf(type) === -1;
    };
    var isShowLevel = function isShowLevel(level) {
        return showLevels.indexOf(level) !== -1;
    };
    /*
    {
        // Type of check that output this suggestion
        type: "so",
         // Level of importance
        // "suggestion", "warning", "error"
        level: "warning",
         // Index in the text
        index: 10,
         // Size of the section in the text
        offset: 2,
         // Message to describe the suggestion
        message: "omit 'So' from the beginning of sentences",
         // Replacements suggestion
        replacements: [
            {
                value: ""
            }
        ]
    }
     */
    var createSuggest = function createSuggest(replacements) {
        if (replacements.length === 0) {
            return "";
        }
        return "\nSuggestions:\n" + replacements.map(function (_ref) {
            var value = _ref.value;

            return "=> " + value;
        }).join("\n");
    };
    var reportError = function reportError(node, source, result) {
        var level = result.level;
        var type = result.type;
        // if not contains showing options, ignore this result
        if (!isShowLevel(level)) {
            return;
        }
        if (!isShowType(type)) {
            return;
        }
        var index = source.originalIndexFromIndex(result.index);
        var suggestions = createSuggest(result.replacements);
        var ruleError = new RuleError(level + "(" + type + ") " + result.message + suggestions, {
            index: index
        });
        report(node, ruleError);
    };

    return _defineProperty({}, Syntax.Paragraph, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var filteredNode = mapNode(node, function (node) {
            var index = ignoreInlineNodeTypes.indexOf(node.type);
            if (index === -1) {
                return node;
            }
            /*
            `xxx` => code
             */
            return ObjectAssign({}, node, {
                value: node.type.toLocaleLowerCase()
            });
        });
        if (!filteredNode) {
            return;
        }
        var source = new StringSource(filteredNode);
        var text = source.toString();
        var reportSourceError = function reportSourceError(results) {
            reportError(node, source, results);
        };
        rousseau(text, function (err, results) {
            if (err) {
                throw err;
            }
            results.forEach(reportSourceError);
        });
    });
}
module.exports = exports['default'];
//# sourceMappingURL=textlint-rule-rousseau.js.map